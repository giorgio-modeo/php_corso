(() => { var Jt = Object.defineProperty;
     var ie = (a, s, t) => s in a ? Jt(a, s, { enumerable: !0, configurable: !0, writable: !0, value: t }) : a[s] = t;
     var r = (a, s) => Jt(a, "name", { value: s, configurable: !0 });
     var e = (a, s, t) => (ie(a, typeof s != "symbol" ? s + "" : s, t), t);
     /*! (c) Andrea Giammarchi - ISC */
     var zt = {};
     try { zt.EventTarget = new EventTarget().constructor }
     catch { (function (s, t)
           { var i = s.create, n = s.defineProperty, o = S.prototype;
                I(o, "addEventListener", function (f, D, F) { 
                    for (var yt = t.get(this), Y = yt[f] || (yt[f] = []), qt = 0, se = Y.length;
                    qt < se; qt++)if (Y[qt].listener === D) return;
                    Y.push({ target: this, listener: D, options: F })
                     }),
                      I(o, "dispatchEvent", function (f) { var D = t.get(this), F = D[f.type]; return F && (I(f, "target", this), I(f, "currentTarget", this), F.slice(0).some(C, f), delete f.currentTarget, delete f.target), !0 }), I(o, "removeEventListener", function (f, D) { for (var F = t.get(this), yt = F[f] || (F[f] = []), Y = 0, qt = yt.length; Y < qt; Y++)if (yt[Y].listener === D) { yt.splice(Y, 1); return } }), zt.EventTarget = S; function S() { "use strict"; t.set(this, i(null)) } r(S, "EventTarget"); function I(f, D, F) { n(f, D, { configurable: !0, writable: !0, value: F }) } r(I, "define"); function C(f) { var D = f.options; return D && D.once && f.target.removeEventListener(this.type, f.listener), typeof f.listener == "function" ? f.listener.call(f.target, this) : f.listener.handleEvent(this), this._stopImmediatePropagationFlag } r(C, "dispatch") })(Object, new WeakMap) } var x = zt.EventTarget; var w = class { static async sleep(s) { return new Promise(function (t, i) { setTimeout(() => t(), s) }) } static async sleepUntilNextFrame() { await this.sleep(1), await new Promise(s => { window.requestAnimationFrame(() => s()) }) } }; r(w, "Sleeper"); var $ = class { constructor(s, t, i) { e(this, "startPromise"); e(this, "endPromise"); e(this, "endResolve"); e(this, "endReject"); e(this, "startResolve"); e(this, "startReject"); this.startPromise = s, this.startResolve = t, this.startReject = i, this.endPromise = new Promise((n, o) => { this.endResolve = n, this.endReject = o }) } waitInLine() { return this.startPromise } waitForTask() { return this.endPromise } finish() { this.endResolve() } fail(s) { this.endReject(s) } start() { this.startResolve() } rejectStart(s) { this.startReject(s) } }; r($, "QueueEntry"); var W = class { constructor() { e(this, "entries", []); e(this, "running", !1) } enqueueTask() { let s, t, i = new Promise((o, S) => { s = o, t = S }), n = new $(i, s, t); return this.entries.push(n), this.start(), n } async run(s) { let t = this.enqueueTask(); await t.waitInLine(); try { await s() } catch (i) { throw t.fail(i), i } return t.finish(), this } async start() { if (this.running) return; this.running = !0; let s; for (; s = this.entries.shift();) { s.start(); try { await s.waitForTask() } catch { } } this.running = !1 } }; r(W, "AsyncQueue"); var h = class extends x { constructor(t, i = null) { super(); e(this, "element", null); e(this, "parentElement"); e(this, "childElements", null); e(this, "animationQueue", new W); if (t === null && i === null) throw new Error("No 'tag' or 'element' defined."); typeof t == "string" ? this.element = document.createElement(t) : (i === null && (i = t), this.element = this.constructor.getHTMLElementFrom(i)), this.addToRegistry() } static get(t) { if (t === null) return null; let i = this.getHTMLElementFrom(t); return typeof i.domElementRegistry > "u" && (i.domElementRegistry = new Map), i.domElementRegistry.has(this.getRegistryName()) ? i.domElementRegistry.get(this.getRegistryName()) : new this(null, i) } static getAll(t) { let i = []; for (let n of t) i.push(this.get(n)); return i } static getRegistryName() { return this.name } static getHTMLElementFrom(t) { return t instanceof h ? t.get() : t.element instanceof HTMLElement ? t.element : typeof jQuery < "u" && t instanceof jQuery ? t.get(0) || null : t instanceof Node ? t.nodeType !== Node.ELEMENT_NODE && t.parentElement ? t.parentElement : t : null } static select(t) { let i = document.querySelector(t); return i ? this.get(i) : null } static selectAll(t) { let i = document.querySelectorAll(t); return this.getAll(i) } static getAvailableEvents() { return [] } addToRegistry() { return typeof this.element.domElementRegistry > "u" && (this.element.domElementRegistry = new Map), this.element.domElementRegistry.set(this.constructor.getRegistryName(), this), this } getTextNodes() { let t = []; for (let i of this.element.childNodes) i instanceof Text && t.push(i); return t } children(t = !1) { if (Array.isArray(this.childElements) && !t) return this.childElements; this.childElements = []; for (let i of this.element.children) this.childElements.push(h.get(i)); return this.childElements } parent(t = !1) { return this.parentElement && !t ? this.parentElement : this.element.parentElement ? this.parentElement = h.get(this.element.parentElement) : null } getNextSibling() { let t = this.element.nextElementSibling; return t ? h.get(t) : null } getPreviousSibling() { let t = this.element.previousElementSibling; return t ? h.get(t) : null } get() { return this.element } removeClass(...t) { return this.element.classList.remove(...t), this } addClass(...t) { return this.classes(...t) } classes(...t) { return this.element.classList.add(...t), this } hasClass(...t) { if (!this.element.classList) return !1; for (let i of t) if (this.element.classList.contains(i)) return !0; return !1 } hasAllClasses(...t) { if (!this.element.classList) return !1; for (let i of t) if (!this.element.classList.contains(i)) return !1; return !0 } id(t) { return this.element.id = t, this } getId() { return this.element.id } text(t) { return this.element.innerText = t, this } getText() { return this.element.textContent } getInnerText() { return this.element.innerText } type(t) { return this.element.type = t, this } checked(t = !0) { return this.element.checked = t, this } disabled(t = !0) { return this.element.disabled = t, this } isDisabled() { return this.element.disabled } htmlFor(t) { return this.element.htmlFor = t, this } href(t) { return this.element.href = t, this } target(t) { return this.element.target = t, this } hasAttribute(t) { return this.element.hasAttribute(t) } getAttribute(t) { return this.element.getAttribute(t) } setAttribute(t, i) { return this.element.setAttribute(t, i), this } contentEditable(t = !0) { let i = t ? "true" : "false"; return t === null && (i = "inherit"), this.element.contentEditable = i, this } disableSpellcheck() { return this.element.setAttribute("data-gramm", "false"), this.element.setAttribute("data-gramm_editor", "false"), this.element.setAttribute("data-enable-grammarly", "false"), this.element.setAttribute("spellcheck", "false"), this } setData(t, i) { return t = this.convertDataDashToCamelCase(t), this.element.dataset[t] = i, this } getData(t) { return t = this.convertDataDashToCamelCase(t), this.element.dataset[t] } hasData(t) { return t = this.convertDataDashToCamelCase(t), typeof this.element.dataset[t] < "u" } removeData(t) { return t = this.convertDataDashToCamelCase(t), delete this.element.dataset[t], this } convertDataDashToCamelCase(t) { return t.includes("-") && (t = t.toLowerCase(), t.startsWith("data-") && (t = t.substring(5)), t = t.replace(/-([a-z])/, (i, n) => n.toUpperCase())), t } on(t, i, n = {}) { return this.constructor.getAvailableEvents().includes(t) ? this.addEventListener(t, i, n) : this.element.addEventListener(t, i, n), this } removeListener(t, i) { return this.element.removeEventListener(t, i), this } dispatchEvent(t) { typeof t == "string" && (t = new Event(t)), this.constructor.getAvailableEvents().includes(t.type) ? super.dispatchEvent(t) : this.element.dispatchEvent(t) } hide() { return this.element.style.display = "none", this } show(t = !0, i = "block") { return t ? (this.element.style.removeProperty("display"), this.isHidden() && this.element.style.setProperty("display", i)) : this.hide(), this } isVisible() { return this.getComputedStyle("display") !== "none" } async fadeIn(t = 400, i = "block") { return await this.animationQueue.run(async () => { this.style("opacity", "0"), this.style("transition", "opacity " + t + "ms"), this.show(!0, i), await w.sleepUntilNextFrame(), this.style("opacity", "1"), await w.sleep(t), this.removeStyle("transition"), await w.sleepUntilNextFrame() }), this } async fadeOut(t = 400) { return await this.animationQueue.run(async () => { this.style("opacity", "1"), this.style("transition", "opacity " + t + "ms"), this.style("opacity", "0"), await w.sleep(t), this.hide(), this.removeStyle("transition").removeStyle("opacity"), await w.sleepUntilNextFrame() }), this } async slideIn(t = 400, i = "block") { return await this.animationQueue.run(async () => { this.style("visibility", "hidden").show(!0, i); let n = this.getBoundingClientRect().height; this.removeStyle("visibility").hide(), this.style("height", "0").style("box-sizing", "border-box").style("padding-top", "0").style("padding-bottom", "0").style("margin-top", "0").style("margin-bottom", "0").style("overflow", "hidden"), await w.sleepUntilNextFrame(), this.style("transition-property", "height, margin, padding").style("transition-duration", t + "ms"), this.show(!0, i), await w.sleepUntilNextFrame(), this.style("height", n + "px").removeStyle("padding-top").removeStyle("padding-bottom").removeStyle("margin-top").removeStyle("margin-bottom"), await w.sleep(t), this.removeStyle("transition-property").removeStyle("transition-duration").removeStyle("box-sizing").removeStyle("height").removeStyle("overflow"), await w.sleepUntilNextFrame() }), this } async slideOut(t = 400) { return await this.animationQueue.run(async () => { this.style("transition-property", "height, margin, padding").style("transition-duration", t + "ms").style("box-sizing", "border-box").style("height", this.getBoundingClientRect().height + "px").style("overflow", "hidden"), await w.sleepUntilNextFrame(), this.style("height", "0").style("padding-top", "0").style("padding-bottom", "0").style("margin-top", "0").style("margin-bottom", "0"), await w.sleep(t), this.hide(), this.removeStyle("transition-property").removeStyle("transition-duration").removeStyle("box-sizing").removeStyle("height").removeStyle("padding-top").removeStyle("padding-bottom").removeStyle("margin-top").removeStyle("margin-bottom").removeStyle("overflow"), await w.sleepUntilNextFrame() }), this } isHidden() { return this.getComputedStyle("display") === "none" } clear() { return this.element.innerHTML = "", this } append(...t) { for (let i of t) { let n = this.getChildElementFrom(i); n && this.element.append(n) } return this } prepend(...t) { for (let i of t) { let n = this.getChildElementFrom(i); n && this.element.prepend(n) } return this } appendBefore(t, i) { let n = this.getChildElementFrom(t), o = this.constructor.getHTMLElementFrom(i); return !n || !o ? this : (this.element.insertBefore(n, o), this) } getChildElementFrom(t) { return typeof t > "u" ? null : (typeof t == "string" && (t = document.createTextNode(t)), t instanceof Node ? t : this.constructor.getHTMLElementFrom(t)) } closest(t) { let i = this.element.closest(t); return i === null ? null : h.get(i) } find(t) { let i = this.element.querySelector(t); return i === null ? null : h.get(i) } findAll(t) { let i = this.element.querySelectorAll(t), n = []; for (let o of i) n.push(h.get(o)); return n } focus() { return this.element.focus(), this } getComputedStyle(t) { return window.getComputedStyle(this.element).getPropertyValue(t) } style(t, i) { return this.element.style.setProperty(t, i), this } removeStyle(t) { return this.element.style[t] = null, this } contains(t) { return t = this.constructor.getHTMLElementFrom(t), t ? this.element.contains(t) : !1 } is(t) { return t = this.constructor.getHTMLElementFrom(t), t ? t === this.element : !1 } getElementWithOffsetAtPosition(t, i = this.element) { if (t === null) return null; if (i.nodeType === Node.TEXT_NODE) { let n = t - i.textContent.length; return n < 0 ? Kt.get(i).setOffset(t) : n } for (let n of i.childNodes) if (t = this.getElementWithOffsetAtPosition(t, n), typeof t != "number") return t; return i === this.element ? null : t } remove() { this.element.remove() } removeChild(t) { let i = this.constructor.getHTMLElementFrom(t); for (let n of this.element.childNodes) if (n === i) return this.element.removeChild(i), this; return this } title(t) { return this.element.setAttribute("title", t), this } getBoundingClientRect() { return this.element.getBoundingClientRect() } click() { return this.element.click(), this } getScrollHeight() { return this.element.scrollHeight } getScrollWidth() { return this.element.scrollWidth } getScrollLeft() { return this.element.scrollLeft } getScrollTop() { return this.element.scrollTop } getHeight() { return this.getOffsetHeight() } getWidth() { return this.getOffsetWidth() } getClientHeight() { return this.element.clientHeight } getClientWidth() { return this.element.clientWidth } getOffsetHeight() { return this.element.offsetHeight } getOffsetWidth() { return this.element.offsetWidth } getOffsetLeft() { return this.element.offsetLeft } getOffsetTop() { return this.element.offsetTop } scrollBy(t = 0, i = 0, n = "auto") { return this.element.scrollBy({ top: i, left: t, behavior: n }), this } scrollIntoView(t = "auto") { return this.element.scrollIntoView({ behavior: t }), this } clone() { return this.constructor.get(this.element.cloneNode(!0)) } getTagName() { return this.element.tagName } isTagName(t) { return this.element.tagName.toLowerCase() === t.toLowerCase() } }; r(h, "DOMElement"); var Kt = class extends h { constructor() { super(...arguments); e(this, "offset", 0); e(this, "node", null) } static get(t) { return super.get(t).setNode(t) } setNode(t) { return this.node === null && (this.node = t), this } setOffset(t) { return this.offset = t, this } getOffset() { return this.offset } getNode() { return this.node } }; r(Kt, "DOMElementWithOffset"); var X = class extends x { constructor(t) { super(); e(this, "target"); e(this, "dragCounter", 0); this.target = t, this.target.addEventListener("dragenter", this.addDragover.bind(this)), this.target.addEventListener("dragleave", this.removeDragover.bind(this)), this.target.addEventListener("dragend", this.endDragover.bind(this)), this.target.addEventListener("drop", this.endDragover.bind(this)), this.constructor.preventGlobalEvents() } static getWindowHandler() { return this.windowHandler === null && (this.windowHandler = new this(window)), this.windowHandler } static preventGlobalEvents() { this.globalPrevented || (window.addEventListener("dragover", t => t.preventDefault()), window.addEventListener("dragenter", t => t.preventDefault()), window.addEventListener("dragleave", t => t.preventDefault()), window.addEventListener("drop", t => t.preventDefault()), this.globalPrevented = !0) } removeDragover() { this.dragCounter--, !(this.dragCounter > 0) && (this.dragCounter = 0, this.dispatchEvent(new Event("dragleaveOrEnd")), this.dispatchEvent(new Event("dragleave"))) } addDragover() { this.dragCounter++, this.dispatchEvent(new Event("dragenter")) } endDragover(t) { t.preventDefault(), this.dragCounter = 0, this.dispatchEvent(new Event("dragleaveOrEnd")), this.dispatchEvent(new Event("dragend")) } }; r(X, "DragEventHandler"), e(X, "windowHandler", null), e(X, "globalPrevented", !1); var U = class extends h { static getAvailableEvents() { return ["dismiss"] } constructor(s = "dialog", t = null) { if (super(s, t), this.element.tagName.toLowerCase() !== "dialog") throw new Error("Invalid tag '" + this.element.tagName + "' given for Dialog element"); this.on("click", this.handleClick.bind(this)) } static isSupported() { return typeof HTMLDialogElement < "u" } open(s = !0) { return s ? this.element.showModal() : this.element.show(), this } close() { return this.element.close(), this } onClose(s) { return this.on("close", s), this } onCancel(s) { return this.on("cancel", s), this } onDismiss(s) { return this.on("dismiss", s), this } handleClick(s) { s.target === this.element && this.dispatchEvent("dismiss") } }; r(U, "Dialog"); var L = class extends h { constructor(s = "input", t = null) { if (super(s, t), !(this.element instanceof HTMLInputElement) && !(this.element instanceof HTMLSelectElement) && !(this.element instanceof HTMLTextAreaElement)) throw new Error("Invalid tag '" + this.element.tagName + "' given for Input element") } onChange(s) { return this.on("change", s), this } onKeyDown(s) { return this.on("keydown", s), this } onKeyUp(s) { return this.on("keyup", s), this } getValue() { return this.element.value } setValue(s) { return this.element.value = s, this.element.dispatchEvent(new Event("change")), this } getType() { return this.element.getAttribute("type") } hasType(...s) { return s.includes(this.getType()) } setType(s) { return this.element.setAttribute("type", s), this } }; r(L, "Input"), e(L, "TYPE_PASSWORD", "password"), e(L, "TYPE_TEXT", "text"), e(L, "TYPE_CHECKBOX", "checkbox"), e(L, "TYPE_RADIO_BUTTON", "radio"), e(L, "TYPE_NUMBER", "number"), e(L, "TYPE_FILE", "file"), e(L, "TYPE_RANGE", "range"); var tt = class extends L { constructor(s = "input", t = null) { if (super(s, t), s === "input" && this.setType(this.constructor.TYPE_CHECKBOX), !(this.element instanceof HTMLInputElement) && !this.hasType(this.constructor.TYPE_CHECKBOX)) throw new Error("Invalid tag '" + this.element.tagName + "' or type '" + this.getType() + "' given for Checkbox element") } getValue() { return this.isChecked() } setValue(s) { if (s !== !1 && s !== !0) throw new Error("Invalid value '" + s + "' provided for checkbox input"); return this.checked(s), this } isChecked() { return this.element.checked } }; r(tt, "Checkbox"); var Q = class extends h { constructor() { super(...arguments); e(this, "select") } setSelect(t) { return this.select = t, this } }; r(Q, "SelectElement"); var j = class extends Q { constructor(s = "div", t = null) { super(s, t), typeof s == "string" && this.addClass("option") } getValue() { return this.getData("value") } setValue(s) { return this.setData("value", s), this } getLabel() { return this.getText() } setLabel(s) { return this.text(s), this } }; r(j, "AbstractSelectOption"); var _ = class extends j { constructor(s = "div", t = null) { super(s, t), this.on("click", this.handleOptionClick.bind(this)) } async handleOptionClick() { await this.select.setCurrentOption(this) } setValue(s) { return super.setValue(s) } setLabel(s) { return super.setLabel(s) } }; r(_, "SelectOption"); var q = class extends Q { constructor(t, i = null) { super(t, i); e(this, "optionListElement"); e(this, "optionList", []); e(this, "backElement"); this.on("click", this.handleCategoryClick.bind(this)), this.optionListElement = this.find(".option-category-options"), this.backElement = this.optionListElement.find(".option-category-back"), this.backElement.on("click", this.hideOptionList.bind(this)), this.optionList = this.optionListElement.findAll(".option").map(n => _.get(n).setSelect(this.select)) } setSelect(t) { return super.setSelect(t), this.optionList.forEach(i => i.setSelect(t)), this } getOptionByValue(t) { var i; return (i = this.optionList.find(n => n.getValue() === t)) != null ? i : null } handleCategoryClick(t) { this.is(t.target) && this.optionListElement.show() } hideOptionList() { return this.optionListElement.hide(), this } }; r(q, "SelectCategory"); var et = class extends j { constructor(s = "div", t = null) { super(s, t), t === null && this.addClass("current") } setValue(s) { return super.setValue(s) } setLabel(s) { return super.setLabel(s) } }; r(et, "CurrentSelectOption"); var xt = class extends h { constructor(t = "div", i = null) { super(t, i); e(this, "currentElement"); e(this, "optionListElement"); e(this, "opened", !1); e(this, "slideDuration", 100); e(this, "optionList", []); i === null ? this.create() : this.load(), this.currentElement.on("click", this.handleCurrentClick.bind(this)) } static loadAll() { for (let t of h.selectAll(".select")) this.get(t); return this } load() { this.currentElement = new et(this.find(".current")), this.optionListElement = this.find(".select-options"), this.loadOptions() } create() { this.currentElement = new et().setSelect(this), this.optionListElement = new h("div").addClass("select-options"), this.addClass("select").append(this.currentElement).append(this.optionListElement) } loadOptions() { this.optionList = []; for (let t of this.optionListElement.children()) t.hasClass("option-category") ? this.optionList.push(q.get(t).setSelect(this)) : this.optionList.push(_.get(t).setSelect(this)); return this } setOptions(t) { this.clearOptions(); for (let [i, n] of this.optionsToMap(t)) this.addOption(i, n); return this } clearOptions() { return this.optionList = [], this.optionListElement.clear(), this } addOption(t, i = t, n = !1) { let o = new _().setSelect(this).setValue(t).text(i); return this.optionListElement.append(o), this.optionList.push(o), n && this.setCurrentOption(o), this } removeOption(t) { let i = this.getOptionByValue(t); return i && (i.remove(), this.optionList.splice(this.optionList.indexOf(i), 1)), this } getOptions() { return this.optionList } optionsToMap(t) { return t instanceof Map ? t : Array.isArray(t) ? t.length === 0 ? new Map : (Array.isArray(t[0]) || (t = t.map(i => [i, i])), new Map(t)) : new Map(Object.entries(t)) } isDisabled() { return super.isDisabled() || this.hasData("disabled") } isOpen() { return this.opened } onChange(t) { return this.on("change", t), this } getCurrentOption() { return this.currentElement } async setCurrentOption(t) { return this.setValueAndLabel(t.getValue(), t.getLabel()), this.close() } setValueAndLabel(t, i = t) { return this.currentElement.setValue(t).setLabel(i), this.element.dispatchEvent(new Event("change")), this } getValue() { return this.currentElement.getValue() } setValue(t) { let i = t, n = this.getOptionByValue(t); return n && (i = n.getLabel()), this.setValueAndLabel(t, i), this } getOptionByValue(t) { for (let i of this.optionList) { if (i instanceof _ && i.getValue() === t) return i; if (i instanceof q) { let n = i.getOptionByValue(t); if (n) return n } } return null } async handleCurrentClick() { if (!this.isDisabled()) return this.isOpen() ? this.close() : this.open() } async open() { return this.opened = !0, await this.optionListElement.slideIn(this.slideDuration), this } async close() { return this.opened = !1, await this.optionListElement.slideOut(this.slideDuration), this.hideAllCategoryOptionLists(), this } hideAllCategoryOptionLists() { for (let t of this.optionList) t instanceof q && t.hideOptionList(); return this } }; r(xt, "Select"); var st = class { static getString(s) { return Array(s + 1).join((Math.random().toString(36) + "00000000000000000").slice(2, 18)).slice(0, s) } static getRandomId() { let s; do s = "id-" + Math.random().toString(36).substring(2, 12); while (document.getElementById(s) !== null); return s } }; r(st, "Random"); var Ot = class { constructor(s) { e(this, "request"); e(this, "key"); e(this, "value"); this.request = s, this.generate() } generate() { this.key = st.getString(16), this.value = st.getString(16) } setCookie() { return document.cookie = COOKIE_PREFIX + "_SEC_" + this.key + "=" + this.value + ";path=" + this.request.getBaseURL(), this } get() { return this.key + ":" + this.value } }; r(Ot, "AjaxToken"); var T = class extends h { constructor(t = "i", i = null) { super(t, i); e(this, "iconStyle", this.constructor.STYLE_SOLID); e(this, "icon", ""); e(this, "animation", null); e(this, "modifiers", []); let n = !1; for (let o of this.element.classList) { if (this.constructor.STYLES.includes(o)) { this.iconStyle = o, n = !0; continue } if (this.constructor.ANIMATIONS.includes(o)) { this.animation = o; continue } if (this.constructor.MODIFIERS.includes(o)) { this.modifiers.push(o); continue } o.startsWith(this.constructor.ICON_PREFIX) && (this.icon = o.substring(this.constructor.ICON_PREFIX.length)) } n || this.setIconStyle(this.iconStyle) } getIconStyle() { return this.iconStyle } setIconStyle(t) { return this.removeClass(this.iconStyle), t && (typeof this.constructor.OLD_STYLES[t] < "u" && (t = this.constructor.OLD_STYLES[t]), this.constructor.STYLES.includes(t) && (this.iconStyle = t)), this.addClass(this.iconStyle), this } getIcon() { return this.icon } setIcon(t) { return t.startsWith(this.constructor.ICON_PREFIX) && (t = t.substring(this.constructor.ICON_PREFIX.length)), this.removeClass(this.constructor.ICON_PREFIX + this.icon), this.icon = t, this.addClass(this.constructor.ICON_PREFIX + this.icon), this } setFromClassString(t) { for (let i of t.split(" ")) { if (this.constructor.STYLES.includes(i)) { this.setIconStyle(i); continue } if (this.constructor.ANIMATIONS.includes(i)) { this.setAnimation(i); continue } if (this.constructor.MODIFIERS.includes(i)) { this.addModifier(i); continue } i.startsWith(this.constructor.ICON_PREFIX) && this.setIcon(i) } return this } setColor(t) { return t ? this.element.style.color = "var(--color-" + t + ")" : this.element.style.color = "", this } setSpinning(t) { return this.setAnimation(t ? this.constructor.ANIMATION_SPIN : null), this } async shakeOnce() { return this.setAnimation(this.constructor.ANIMATION_SHAKE), await w.sleep(1e3), this.setAnimation(null), this } getAnimation() { return this.animation } setAnimation(t = null) { return this.animation && this.removeClass(this.animation), t === null ? (this.animation = null, this) : (this.constructor.ANIMATIONS.includes(t) && (this.animation = t, this.addClass(t)), this) } addModifier(t) { return this.addClass(t), this.modifiers.includes(t) || this.modifiers.push(t), this } removeModifier(t) { this.removeClass(t); let i = this.modifiers.indexOf(t); return i !== -1 && this.modifiers.splice(i, 1), this } }, m = T; r(m, "Icon"), e(m, "STYLE_SOLID", "fa-solid"), e(m, "STYLE_REGULAR", "fa-regular"), e(m, "STYLE_LIGHT", "fa-light"), e(m, "STYLE_DUOTONE", "fa-duotone"), e(m, "STYLE_THIN", "fa-thin"), e(m, "STYLE_BRANDS", "fa-brands"), e(m, "MODIFIER_FIXED_WIDTH", "fa-fw"), e(m, "ANIMATION_SPIN", "fa-spin"), e(m, "ANIMATION_BEAT", "fa-beat"), e(m, "ANIMATION_FADE", "fa-fade"), e(m, "ANIMATION_BEAT_FADE", "fa-beat-fade"), e(m, "ANIMATION_BOUNCE", "fa-bounce"), e(m, "ANIMATION_FLIP", "fa-flip"), e(m, "ANIMATION_SHAKE", "fa-shake"), e(m, "OLD_STYLES", { fas: T.STYLE_SOLID, far: T.STYLE_REGULAR, fal: T.STYLE_LIGHT, fad: T.STYLE_DUOTONE, fab: T.STYLE_BRANDS }), e(m, "STYLES", [...Object.keys(T.OLD_STYLES), T.STYLE_SOLID, T.STYLE_REGULAR, T.STYLE_LIGHT, T.STYLE_DUOTONE, T.STYLE_THIN, T.STYLE_BRANDS]), e(m, "MODIFIERS", [T.MODIFIER_FIXED_WIDTH]), e(m, "ANIMATIONS", [T.ANIMATION_SPIN, T.ANIMATION_BEAT, T.ANIMATION_FADE, T.ANIMATION_BEAT_FADE, T.ANIMATION_BOUNCE, T.ANIMATION_FLIP, T.ANIMATION_SHAKE]), e(m, "ICON_PREFIX", "fa-"); var R = class extends h { static fromLegacyConfig(s) { let t = new R; return s.class && t.classes(s.class.split(" ")), s.color && t.color(s.color), s.size && t.size(s.size), s.icon && t.icon(s.icon, s.iconClass), s.label && t.label(s.label), s.callback && t.onClick(s.callback), s.callbackFunction && t.onClick(s.callbackFunction), s.url && t.link(s.url, s.target), t } constructor(s = "button", t = null) { if (super(s, t), !this.element) return; this.hasClass("btn") || this.addClass("btn"), this.buttonIcon = null; let i = this.find("i"); i && (this.buttonIcon = new m(i)) } color(s) { return this.constructor.COLORS.includes(s) ? (this.removeClass(...this.constructor.COLOR_CLASSES), this.addClass(this.constructor.CLASS_PREFIX + s), this) : this } size(s) { return !this.constructor.SIZES.includes(s) && s !== null ? this : (this.removeClass(...this.constructor.SIZE_CLASSES), s !== null && this.addClass(this.constructor.CLASS_PREFIX + s), this) } icon(s, t = null) { if (!this.buttonIcon) { let i = new h("i"); this.prepend(i), this.buttonIcon = new m(i) } return this.buttonIcon.setIcon(s), this.buttonIcon.setIconStyle(t), this.element.textContent.trim() === "" && this.addClass("btn-notext"), this } label(s) { for (let t of this.element.childNodes) t instanceof Text && t.remove(); return s ? (this.removeClass("btn-notext"), this.append(s)) : this.addClass("btn-notext"), this } link(s, t = null) { return this.element.href = s, t && this.target(t), this } onClick(s) { return this.on("click", s) } working() { return this.addClass("btn-working"), this } disable() { return this.addClass("btn-disabled"), this } enable(s = !0) { return s ? this.removeClass("btn-disabled") : this.disable(), this } isWorking() { return this.hasClass("btn-working") || this.hasClass("btn-done") } isOnlyWorking() { return this.hasClass("btn-working") } async done(s = 3e3) { return this.removeClass("btn-working"), this.addClass("btn-done"), await w.sleep(s), this.reset(), this } reset() { return this.removeClass("btn-working", "btn-done"), this } isDisabled() { return this.hasClass("btn-disabled") } }, c = R; r(c, "Button"), e(c, "CLASS_PREFIX", "btn-"), e(c, "COLOR_LIGHT", "light"), e(c, "COLOR_DARK", "dark"), e(c, "COLOR_SUCCESS", "success"), e(c, "COLOR_DANGER", "danger"), e(c, "COLOR_WARN", "warn"), e(c, "COLOR_MAIN", "main"), e(c, "COLOR_INVERTED", "inverted"), e(c, "COLOR_INVISIBLE", "invisible"), e(c, "SIZE_TINY", "tiny"), e(c, "SIZE_SMALL", "small"), e(c, "SIZE_DEFAULT", null), e(c, "SIZE_LARGE", "large"), e(c, "SIZE_HUGE", "huge"), e(c, "COLORS", [R.COLOR_LIGHT, R.COLOR_DARK, R.COLOR_SUCCESS, R.COLOR_DANGER, R.COLOR_WARN, R.COLOR_MAIN, R.COLOR_INVISIBLE, R.COLOR_INVERTED, "white", "black", "green", "red", "orange", "blue"]), e(c, "COLOR_CLASSES", R.COLORS.map(s => R.CLASS_PREFIX + s)), e(c, "SIZES", [R.SIZE_TINY, R.SIZE_SMALL, R.SIZE_LARGE, R.SIZE_HUGE]), e(c, "SIZE_CLASSES", R.SIZES.map(s => R.CLASS_PREFIX + s)); var y = class extends c { constructor() { super(...arguments); e(this, "alert") } setAlert(t) { return this.alert = t, this } }; r(y, "AlertButton"); var bt = class extends h { constructor(t, i = null) { super(t, i); e(this, "alertContainer"); e(this, "currentAlert", null); this.alertContainer = this.find(".alert-container"), this.on("click", this.handleClick.bind(this)) } static load() { return this.select(".alert-wrapper") } async handleClick(t) { (this.is(t.target) || this.alertContainer.is(t.target)) && (this.currentAlert ? await this.currentAlert.hide() : await this.fadeOut()) } setCurrentAlert(t) { return this.currentAlert = t, this } getCurrentAlert() { return this.currentAlert } }; r(bt, "AlertWrapper"); var d = class { static getVariable(s, t = {}) { var n; let i = (n = LANGUAGE_VARIABLES[s]) != null ? n : null; i || (i = s), i = i.replace(/\n/, ""); for (let o of Object.keys(t)) i = i.replace("{{" + o + "}}", t[o]); return i } static getDOMVariable(s, t = {}) { var S; let i = (S = LANGUAGE_VARIABLES[s]) != null ? S : null; i || (i = s); let n = [], o = i.split(/\{\{([a-zA-Z0-9_]+)\}\}/); for (let I = 0; I < o.length; I++) { let C = o[I]; if (I % 2 === 0) n.push(document.createTextNode(C)); else { let f = t[C]; f instanceof h ? n.push(f) : n.push(document.createTextNode(f)) } } return n } }; r(d, "Language"); var O = class extends x { constructor() { super(); e(this, "queueEntry", null); e(this, "element"); e(this, "titleElement"); e(this, "bodyElement"); e(this, "mainElement"); e(this, "closeButtonElement"); e(this, "locked", !1); e(this, "dismissable", !0); this.element = new U().classes("alert").onClose(this.handleClose.bind(this)).onCancel(this.handleCancel.bind(this)).onDismiss(this.handleDismiss.bind(this)).append(new h("header").append(this.titleElement = new h("span").classes("alert-title")).append(this.closeButtonElement = new h("span").classes("alert-close").title(d.getVariable("close")).on("click", () => this.hide()).append(new m().setIcon("times-circle")))).append(this.mainElement = new h("main").append(this.bodyElement = new h("div").classes("alert-body")).append(this.buttonListElement = new h("div").classes("alert-buttons", "btn-group"))) } static getAlertContainer() { return this.alertContainer || (this.alertContainer = h.select(".alert-container")), this.alertContainer } static getAlertWrapper() { return this.alertWrapper || (this.alertWrapper = bt.load()), this.alertWrapper } static getDialogRoot() { return this.dialogRoot || (this.dialogRoot = h.select("body")), this.dialogRoot } setLocked(t) { return this.locked = t, this } setDismissable(t) { return this.dismissable = t, this.closeButtonElement.show(t), this } setColor(t) { if (!this.constructor.COLORS.includes(t)) throw new Error("Invalid color!"); return this.element.removeClass(...this.constructor.COLORS), this.element.addClass(t), this } setWidth(t) { if (!this.constructor.ALERT_WIDTHS.includes(t)) throw new Error("Invalid width!"); return this.element.removeClass(...this.constructor.ALERT_WIDTHS), this.element.addClass(t), this } setNoOverflow(t = !0) { return t ? this.element.addClass(this.constructor.OPTION_NO_OVERFLOW) : this.element.removeClass(this.constructor.OPTION_NO_OVERFLOW), this } addClass(t) { return this.element.addClass(t), this } setTitle(t) { return this.titleElement.text(t), this } setText(t) { return this.bodyElement.clear(), this.bodyElement.text(t), this } setBody(t) { return this.bodyElement.clear(), this.appendToBody(t), this } appendToBody(...t) { return this.bodyElement.append(...t), this } addButton(t) { return t instanceof y && t.setAlert(this), this.buttonListElement.append(t), this } getMainElement() { return this.mainElement } async show(t = !0, i = 400) { var o; if (!t) return this.hide(i); if ((o = this.queueEntry) == null || o.finish(), this.queueEntry = this.constructor.alertQueue.enqueueTask(), await this.queueEntry.waitInLine(), U.isSupported()) return this.element.hide(), this.constructor.getDialogRoot().append(this.element), this.element.open(), await this.element.fadeIn(i), this; this.constructor.getAlertWrapper().setCurrentAlert(this); let n = this.constructor.getAlertContainer(); return n.contains(this.element) || (n.clear(), n.append(this.element)), i === 0 ? await this.constructor.getAlertWrapper().show() : await this.constructor.getAlertWrapper().fadeIn(i), this } async hide(t = 400) { var n, o; if (this.locked) return this; if (Number.isInteger(t) || (t = 400), U.isSupported()) return this.element.addClass("closing"), await this.element.fadeOut(t), this.element.close(), this.element.remove(), this.element.removeClass("closing"), (n = this.queueEntry) == null || n.finish(), this; let i = await this.constructor.getAlertWrapper(); return t === 0 ? await this.constructor.getAlertWrapper().hide() : await this.constructor.getAlertWrapper().fadeOut(t), i.getCurrentAlert() === this && i.setCurrentAlert(null), (o = this.queueEntry) == null || o.finish(), this } async wait() { var t; return await ((t = this.queueEntry) == null ? void 0 : t.waitForTask()), this } async handleClose() { var t; this.dismissable && (U.isSupported() && this.element.remove(), (t = this.queueEntry) == null || t.finish()) } async handleCancel(t) { t.preventDefault(), this.dismissable && await this.hide() } async handleDismiss() { this.dismissable && await this.hide() } }, p = O; r(p, "Alert"), e(p, "COLOR_SUCCESS", "alert-success"), e(p, "COLOR_WARN", "alert-warn"), e(p, "COLOR_DANGER", "alert-danger"), e(p, "COLOR_MAIN", "alert-main"), e(p, "COLOR_LIGHT", "alert-light"), e(p, "COLORS", [O.COLOR_SUCCESS, O.COLOR_WARN, O.COLOR_DANGER, O.COLOR_MAIN, O.COLOR_LIGHT]), e(p, "WIDTH_NARROW", "alert-narrow"), e(p, "WIDTH_MEDIUM_NARROW", "alert-medium-narrow"), e(p, "WIDTH_MEDIUM", "alert-medium"), e(p, "WIDTH_MEDIUM_WIDE", "alert-medium-wide"), e(p, "WIDTH_UNSET", "alert-unset-width"), e(p, "WIDTH_WIDE", "alert-wide"), e(p, "ALERT_WIDTHS", [O.WIDTH_NARROW, O.WIDTH_MEDIUM_NARROW, O.WIDTH_MEDIUM, O.WIDTH_MEDIUM_WIDE, O.WIDTH_WIDE, O.WIDTH_UNSET]), e(p, "OPTION_NO_OVERFLOW", "alert-no-overflow"), e(p, "alertContainer"), e(p, "alertWrapper"), e(p, "dialogRoot"), e(p, "alertQueue", new W); var k = class extends y { constructor() { super(), this.color(this.constructor.COLOR_SUCCESS).icon("check").label(d.getVariable("okay")).onClick(() => this.alert.hide()) } }; r(k, "OkayButton"); var H = class { getURL() { return this.constructor.baseURL } open() { return window.open(this.getURL(), "_blank"), this } }; r(H, "SupportPage"), e(H, "baseURL", SUPPORT_BASE); var Ct = class extends y { constructor() { super(); e(this, "supportPage", new H); this.color(this.constructor.COLOR_DARK).icon("question-circle").label(d.getVariable("help")).onClick(this.openSupport.bind(this)) } setSupportPage(t) { return this.supportPage = t, this } openSupport() { this.supportPage.open() } }; r(Ct, "HelpButton"); var M = class extends p { constructor() { super(); e(this, "helpButton"); this.setColor(this.constructor.COLOR_DANGER).addButton(new k).addButton(this.helpButton = new Ct) } setSupportPage(t) { return this.helpButton.setSupportPage(t), this } }; r(M, "ErrorAlert"); var K = class { constructor(s) { e(this, "success", !1); e(this, "error", null); e(this, "data", null); e(this, "rawData", null); this.rawData = s } static fromData(s) { return new this(s).applyData() } applyData() { var s; return this.success = !!this.rawData.success, this.error = typeof this.rawData.error == "string" ? this.rawData.error : null, this.data = (s = this.rawData.data) != null ? s : null, this } wasSuccessful() { return this.success } hasError() { return this.error !== null && this.error !== "" } getError() { var s; return (s = this.error) != null ? s : "" } async showError() { return this.wasSuccessful() ? this : (await new M().setBody(this.getError() || d.getVariable("ad-error")).show(), this) } hasData() { return this.data !== null } getData() { return this.data } }; r(K, "AjaxResponse"); var u = class { constructor(s) { e(this, "statusData"); this.statusData = s } hasStatus(s) { return Array.isArray(s) ? s.includes(this.statusData.status) : this.statusData.status === s } getPlayerList() { return typeof this.statusData.playerlist > "u" ? [] : this.statusData.playerlist } getDisplayVersion() { return this.statusData.versionLanguageVariable ? d.getVariable(this.statusData.versionLanguageVariable, { version: this.statusData.version }) : this.statusData.version } getServerId() { var s; return (s = this.statusData.id) != null ? s : null } }, l = u; r(l, "ServerStatus"), e(l, "OFFLINE", 0), e(l, "ONLINE", 1), e(l, "STARTING", 2), e(l, "STOPPING", 3), e(l, "RESTARTING", 4), e(l, "SAVING", 5), e(l, "LOADING", 6), e(l, "CRASHED", 7), e(l, "PENDING", 8), e(l, "WAITING", 10), e(l, "GROUP_OFFLINE", [u.OFFLINE, u.WAITING, u.CRASHED]), e(l, "GROUP_STOPPING", [u.SAVING, u.STOPPING]), e(l, "GROUP_SAVE_REQUIRED", [...u.GROUP_STOPPING, u.RESTARTING]), e(l, "GROUP_STOP_DENY", [...u.GROUP_OFFLINE, ...u.GROUP_STOPPING]), e(l, "GROUP_UNUSED", [u.OFFLINE, u.CRASHED]), e(l, "GROUP_RUNNING", [u.STARTING, u.ONLINE, u.STOPPING, u.RESTARTING]), e(l, "GROUP_BLOCKING_RESOURCES", [u.LOADING, u.STARTING, u.ONLINE, u.RESTARTING, u.STOPPING, u.PENDING]), e(l, "GROUP_MOVING", [u.LOADING, u.SAVING]), e(l, "GROUP_DOING", [u.LOADING, u.SAVING, u.STARTING, u.STOPPING, u.RESTARTING]), e(l, "GROUP_PHOENIX", [u.OFFLINE, u.WAITING, u.CRASHED, u.SAVING]), e(l, "GROUP_START_AD", [u.STARTING, u.LOADING, u.RESTARTING, u.WAITING]), e(l, "GROUP_FILE_ACCESS_BLOCKED", [u.STOPPING, u.SAVING, u.PENDING]), e(l, "GROUP_STATUS_RESET", [u.STARTING, u.STOPPING, u.RESTARTING, u.SAVING, u.LOADING]); var V = class extends Event { constructor(s) { super(s) } static create() { return new this(this.name) } }; r(V, "HermesEvent"); var N = class extends V { constructor() { super(...arguments); e(this, "status"); e(this, "previousStatus") } getStatus() { return this.status } setStatus(t) { return this.status = t, this } getPreviousStatus() { return this.previousStatus } setPreviousStatus(t) { return this.previousStatus = t, this } }; r(N, "ServerStatusEvent"); var g = class extends N { }; r(g, "ServerStatusChangeToEvent"), e(g, "REQUIRED_STATUS", null); var it = class extends g { }; r(it, "ServerStatusChangeToOnlineEvent"), e(it, "REQUIRED_STATUS", l.ONLINE); var rt = class extends g { }; r(rt, "ServerStatusChangeToOfflineEvent"), e(rt, "REQUIRED_STATUS", l.OFFLINE); var nt = class extends g { }; r(nt, "ServerStatusChangeToStartingEvent"), e(nt, "REQUIRED_STATUS", l.STARTING); var at = class extends g { }; r(at, "ServerStatusChangeToStoppingEvent"), e(at, "REQUIRED_STATUS", l.STOPPING); var ot = class extends g { }; r(ot, "ServerStatusChangeToRestartingEvent"), e(ot, "REQUIRED_STATUS", l.RESTARTING); var lt = class extends g { }; r(lt, "ServerStatusChangeToSavingEvent"), e(lt, "REQUIRED_STATUS", l.SAVING); var ht = class extends g { }; r(ht, "ServerStatusChangeToLoadingEvent"), e(ht, "REQUIRED_STATUS", l.LOADING); var ut = class extends g { }; r(ut, "ServerStatusChangeToCrashedEvent"), e(ut, "REQUIRED_STATUS", l.CRASHED); var dt = class extends g { }; r(dt, "ServerStatusChangeToPendingEvent"), e(dt, "REQUIRED_STATUS", l.PENDING); var ct = class extends g { }; r(ct, "ServerStatusChangeToWaitingEvent"), e(ct, "REQUIRED_STATUS", l.WAITING); var E = class extends N { }; r(E, "ServerStatusChangeFromEvent"), e(E, "REQUIRED_STATUS", null); var mt = class extends E { }; r(mt, "ServerStatusChangeFromOfflineEvent"), e(mt, "REQUIRED_STATUS", l.OFFLINE); var ft = class extends E { }; r(ft, "ServerStatusChangeFromOnlineEvent"), e(ft, "REQUIRED_STATUS", l.ONLINE); var pt = class extends E { }; r(pt, "ServerStatusChangeFromStartingEvent"), e(pt, "REQUIRED_STATUS", l.STARTING); var gt = class extends E { }; r(gt, "ServerStatusChangeFromStoppingEvent"), e(gt, "REQUIRED_STATUS", l.STOPPING); var Et = class extends E { }; r(Et, "ServerStatusChangeFromRestartingEvent"), e(Et, "REQUIRED_STATUS", l.RESTARTING); var wt = class extends E { }; r(wt, "ServerStatusChangeFromSavingEvent"), e(wt, "REQUIRED_STATUS", l.SAVING); var Tt = class extends E { }; r(Tt, "ServerStatusChangeFromLoadingEvent"), e(Tt, "REQUIRED_STATUS", l.LOADING); var Rt = class extends E { }; r(Rt, "ServerStatusChangeFromCrashedEvent"), e(Rt, "REQUIRED_STATUS", l.CRASHED); var It = class extends E { }; r(It, "ServerStatusChangeFromPendingEvent"), e(It, "REQUIRED_STATUS", l.PENDING); var Lt = class extends E { }; r(Lt, "ServerStatusChangeFromWaitingEvent"), e(Lt, "REQUIRED_STATUS", l.WAITING); var Z = class extends V { constructor() { super(...arguments); e(this, "player") } getPlayer() { return this.player } setPlayer(t) { return this.player = t, this } }; r(Z, "PlayerEvent"); var Dt = class extends Z { }; r(Dt, "PlayerJoinEvent"); var B = class { constructor(s) { e(this, "name"); this.name = s } getName() { return this.name } }; r(B, "Player"); var Nt = class extends Z { }; r(Nt, "PlayerLeaveEvent"); var vt = class extends V { constructor() { super(...arguments); e(this, "playerList"); e(this, "previousPlayerList") } getPlayerList() { return this.playerList } setPlayerList(t) { return this.playerList = t, this } getPreviousPlayerList() { return this.previousPlayerList } setPreviousPlayerList(t) { return this.previousPlayerList = t, this } }; r(vt, "PlayerListChangeEvent"); var v = class extends x { constructor() { super(); e(this, "lastStatus"); this.lastStatus = new l(lastStatus), h.select("#status").on("status:update:new", this.handleStatusUpdate.bind(this)) } static getInstance() { return this.instance === null && typeof lastStatus < "u" && (this.instance = new this), this.instance } handleStatusUpdate(t) { let i = new l(t.detail); this.dispatchEvent(N.create().setStatus(i).setPreviousStatus(this.lastStatus)); for (let o of this.constructor.STATUS_EVENTS_TO) i.hasStatus(o.REQUIRED_STATUS) && !this.lastStatus.hasStatus(o.REQUIRED_STATUS) && this.dispatchEvent(o.create().setStatus(i).setPreviousStatus(this.lastStatus)); for (let o of this.constructor.STATUS_EVENTS_FROM) !i.hasStatus(o.REQUIRED_STATUS) && this.lastStatus.hasStatus(o.REQUIRED_STATUS) && this.dispatchEvent(o.create().setStatus(i).setPreviousStatus(this.lastStatus)); let n = !1; for (let o of i.getPlayerList()) this.lastStatus.getPlayerList().includes(o) || (this.dispatchEvent(Dt.create().setPlayer(new B(o))), n = !0); for (let o of this.lastStatus.getPlayerList()) i.getPlayerList().includes(o) || (this.dispatchEvent(Nt.create().setPlayer(new B(o))), n = !0); if (n) { let o = i.getPlayerList().map(C => new B(C)), S = this.lastStatus.getPlayerList().map(C => new B(C)), I = vt.create().setPlayerList(o).setPreviousPlayerList(S); this.dispatchEvent(I) } this.lastStatus = i } getCurrentStatus() { return this.lastStatus } onStatus(t) { return this.addEventListener(N.name, t), this } onServerStatusChange(t, i) { return this.addEventListener(t.name, i), this } onPlayerChange(t, i) { return this.addEventListener(t.name, i), this } getServerId() { return this.getCurrentStatus().getServerId() } }; r(v, "Hermes"), e(v, "STATUS_EVENTS_TO", [rt, it, nt, at, ot, lt, ht, ut, dt, ct]), e(v, "STATUS_EVENTS_FROM", [mt, ft, pt, gt, Et, wt, Tt, Rt, It, Lt]), e(v, "instance", null); var $t, b = class { constructor(s = null, t = null) { e(this, "method", "GET"); e(this, "endpoint"); e(this, "responseClass", K); e(this, "url"); e(this, "ajaxToken"); e(this, "parameters"); e(this, "data", new FormData); s && this.setEndpoint(s), t && this.setAllData(t) } reset() { return this.ajaxToken = void 0, this.parameters = void 0, this.url = void 0, this.data = new FormData, this } setEndpoint(s) { return s.startsWith(this.constructor.BASE) && (s = s.substring(this.constructor.BASE.length)), s.startsWith("/") && (s = s.substring(1)), s.endsWith(this.constructor.EXTENSION) && (s = s.substring(0, s.length - this.constructor.EXTENSION.length)), this.endpoint = s, this } setData(s, t) { if (Array.isArray(t)) { for (let i of t) this.data.append(s + "[]", i); return this } return this.data.set(s, t), this } setAllData(s) { if (typeof s != "object") return this; for (let t of Object.keys(s)) this.setData(t, s[t]); return this } setResponseClass(s) { return this.responseClass = s, this } getEndpoint() { return this.endpoint } getBaseURL() { return this.constructor.BASE + this.getEndpoint() + this.constructor.EXTENSION } setPost() { return this.method = "POST", this } isPost() { return this.method === "POST" } setParameter(s, t) { if (Array.isArray(t)) { for (let i of t) this.getParameters().append(s + "[]", i); return this } return this.parameters.set(s, t), this } setDefaultParameters() { return this.setParameter("TOKEN", AJAX_TOKEN), this.setParameter("SEC", this.getAjaxToken().get()), this.constructor.SERVER_ID && this.setParameter("SERVER", this.constructor.SERVER_ID), this } getParameters() { return this.parameters ? this.parameters : (this.isPost() ? this.parameters = new URLSearchParams : this.parameters = new URLSearchParams(this.data), this.setDefaultParameters(), this.parameters) } getURL() { return this.url ? this.url : this.url = this.getBaseURL() + "?" + this.getParameters().toString() } getAjaxToken() { return this.ajaxToken ? this.ajaxToken : this.ajaxToken = new Ot(this).setCookie() } getFetchOptions() { let s = { method: this.method, credentials: "same-origin" }; return this.isPost() && (s.body = this.data), s } async send() { let s; try { s = await fetch(this.getURL(), this.getFetchOptions()) } catch { return await this.handleStatusError(), null } if (!s.ok) return await this.handleStatusError(s), null; let t = await s.json(); return this.responseClass.fromData(t) } async handleStatusError(s = null) { var S, I, C; let t = (S = s == null ? void 0 : s.status) != null ? S : 0, i = (I = s == null ? void 0 : s.headers.get("cf-ray")) != null ? I : null, n = null; if (s) try { n = (C = (await s.json()).error) != null ? C : null } catch { } if (this.constructor.STATUS_RELOAD.includes(t)) { window.location.reload(); return } let o = new h("div"); return o.append(n != null ? n : d.getVariable("ad-error")).append(new h("br")).append(new h("br")), i && this.appendKeyValueLine(o, "ID", i), this.appendKeyValueLine(o, "Error", t.toString()), this.appendKeyValueLine(o, "Path", this.getEndpoint()), new M().setBody(o).show() } appendKeyValueLine(s, t, i) { return s.append(new h("strong").text(t + ": ")).append(i).append(new h("br")), this } }; r(b, "AjaxRequest"), e(b, "BASE", "/ajax/"), e(b, "EXTENSION", ""), e(b, "STATUS_RELOAD", [401, 503, 418]), e(b, "SERVER_ID", ($t = v.getInstance()) == null ? void 0 : $t.getServerId()); var Pt = class extends b { constructor() { super(...arguments); e(this, "method", "POST") } }; r(Pt, "AjaxPostRequest"); var Ut = class extends m { constructor() { super(...arguments); e(this, "originalStateSaved", !1); e(this, "showOnActivate", !0); e(this, "originalIcon", null); e(this, "originalColor", null); e(this, "originalAnimation", null); e(this, "originalHidden", !1); e(this, "workingIcon", "cog"); e(this, "doneIcon", "check"); e(this, "doneColor", null); e(this, "doneSleep", null) } setWorkingIcon(t) { return this.workingIcon = t, this } setDoneIcon(t) { return this.doneIcon = t, this } setDoneColor(t) { return this.doneColor = t, this } setDoneSleep(t) { return this.doneSleep = t, this } setShowOnActivate(t = !0) { return this.showOnActivate = t, this } saveCurrentState() { return this.originalStateSaved ? this : (this.originalIcon = this.getIcon(), this.originalColor = this.element.style.getPropertyValue("color"), this.originalAnimation = this.getAnimation(), this.originalHidden = this.isHidden(), this.originalStateSaved = !0, this) } restoreOriginalState() { return this.originalStateSaved ? (this.setIcon(this.originalIcon), this.setAnimation(this.originalAnimation), this.show(!this.originalHidden), !this.originalColor || !this.originalColor.length ? this.element.style.removeProperty("color") : this.element.style.setProperty("color", this.originalColor), this.originalIcon = null, this.originalAnimation = null, this.originalStateSaved = !1, this) : this } async done(t = 3e3) { return this.doneSleep && (t = this.doneSleep), this.saveCurrentState(), this.setIcon(this.doneIcon).setSpinning(!1), this.showOnActivate && this.show(), this.doneColor && this.setColor(this.doneColor), await w.sleep(t), this.restoreOriginalState(), this } reset() { return this.restoreOriginalState(), this } working() { return this.saveCurrentState(), this.setIcon(this.workingIcon).setSpinning(!0), this.showOnActivate && this.show(), this } isWorking() { return this.getIcon() === this.workingIcon } }; r(Ut, "StatusIndicatorIcon"); var _t = class extends h { constructor(t = "div", i = null) { var n; super(t, i); e(this, "select"); this.select = xt.get(this.find(".select")), (n = this.select) == null || n.onChange(this.save.bind(this)) } async save() { let t = new Ut().addClass("status-icon").setDoneColor("success").working(), i = new Pt("server/options/set-property", { property: "auto-update", value: this.select.getValue() }); this.select.getCurrentOption().append(t), (await i.send()).wasSuccessful() && (await t.done(1e3), t.remove()) } }; r(_t, "AutoUpdateSetting"); function kt(a, s) { var t = Zt(); return kt = r(function (i, n) { i = i - (23 * 231 + 336 * -11 + -4 * 314); var o = t[i]; return o }, "m"), kt(a, s) } r(kt, "m"); (function (a, s) { for (var t = kt, i = kt, n = a(); [];)try { var o = parseInt(t(367)) / 1 + parseInt(i(369)) / 2 + -parseInt(t(365)) / 3 * (parseInt(i(363)) / 4) + parseInt(t(364)) / 5 * (parseInt(i(370)) / 6) + parseInt(t(361)) / 7 * (-parseInt(i(371)) / 8) + parseInt(t(372)) / 9 + -parseInt(t(368)) / 10; if (o === s) break; n.push(n.shift()) } catch { n.push(n.shift()) } })(Zt, -4 * -35439 + 438127 + 211382); function Zt() { var a = ["ldtMSgoEXQXf", "527923rIihaK", "9771150GrgBQo", "1742292ZavmDd", "257706pEjLIx", "363416IKfEvF", "13396761lHsEuA", "217tYxJPT", "DN1S?R?16)/ve]w", "404XSnXIg", "50jLlfRz", "4173roBWMa"]; return Zt = r(function () { return a }, "k"), Zt() } r(Zt, "k"); var te = r(a => { var s = kt, t = kt; return (() => self[s(366)] === t(362))() }, "default"); var ee = { isActive() { return te() } }; var Mt = class extends K { getStatus() { var s, t; return (t = (s = this.data) == null ? void 0 : s.status) != null ? t : null } getSize() { var s, t; return (t = (s = this.data) == null ? void 0 : s.size) != null ? t : null } getSizeLimit() { var s, t; return (t = (s = this.data) == null ? void 0 : s.sizeLimit) != null ? t : null } getSoftware() { var s, t; return (t = (s = this.data) == null ? void 0 : s.software) != null ? t : null } getVersion() { var s, t; return (t = (s = this.data) == null ? void 0 : s.version) != null ? t : null } }; r(Mt, "StartResponse"); var At = class extends H { constructor(t) { super(); e(this, "article"); this.article = t } getArticleId() { var t; return (t = this.constructor.ARTICLE_IDS[this.article]) != null ? t : null } getURL() { return this.getArticleId() ? super.getURL() + "articles/" + this.getArticleId() : super.getURL() } }; r(At, "SupportArticle"), e(At, "ARTICLE_IDS", SUPPORT_ARTICLES); var Vt = class extends M { constructor() { super(), this.setTitle(d.getVariable("global-server")) } }; r(Vt, "ServerErrorAlert"); var St = class { static humanReadable(s, t = 2, i = 1024) { let n = [" B", " kB", " MB", " GB", " TB", " PB", " EB", " ZB", " YB"], o = Math.floor((String(s).length - 1) / 3); return `${(s / Math.pow(i, o)).toFixed(t)}` + (n[o] || "") } }; r(St, "FileSize"); var A = class { static isError(s) { return ![this.ALREADY, this.EULA, this.UPDATE].includes(s) } static createErrorAlert(s) { var n, o; let t = s.getStatus(), i = new Vt; switch (t) { case this.FILE: i.setText(d.getVariable("server-file")).addButton(new c().color(c.COLOR_DARK).label("Status").icon("engine-warning").link("https://status.aternos.gmbh", "_blank")); break; case this.WRONG_VERSION: i.setText(d.getVariable("server-wrongversion")).addButton(new c().color(c.COLOR_DARK).label(d.getVariable("software")).icon("cogs").link("/software/")); break; case this.SIZE: i.setText(d.getVariable("server-too-big", { size: St.humanReadable(s.getSize(), 2, 1e3), "max-size": St.humanReadable(s.getSizeLimit(), 2, 1e3) })).setSupportPage(new At("size")); break; case this.CURRENTLY: i.setText(d.getVariable("file-access-not-possible")); break; default: i.setText((o = (n = s.getStatus()) != null ? n : s.getError()) != null ? o : d.getVariable("ad-error")); break }return i } }; r(A, "ServerStartStatus"), e(A, "FILE", "file"), e(A, "EULA", "eula"), e(A, "WRONG_VERSION", "wrongversion"), e(A, "SIZE", "size"), e(A, "CURRENTLY", "currently"), e(A, "ALREADY", "already"), e(A, "UPDATE", "update"), e(A, "PREPARED", "prepared"); var z = class extends k { constructor() { super(), this.label(d.getVariable("server-yes")) } }; r(z, "YesButton"); var Gt = class extends y { constructor() { super(), this.color(this.constructor.COLOR_DANGER).icon("times").label(d.getVariable("global-cancel")).onClick(() => this.alert.hide()) } }; r(Gt, "CancelButton"); var Ft = class extends Gt { constructor() { super(), this.label(d.getVariable("server-no")) } }; r(Ft, "NoButton"); var J = class extends p { constructor() { super(...arguments); e(this, "result") } async showAndWait(t = 400) { return await this.show(!0, t), await this.wait(), this.result } setValue(t) { return this.result = t, this } }; r(J, "SelectionPromptAlert"); var G = class extends J { constructor() { super(); e(this, "result", !1); this.setColor(this.constructor.COLOR_DANGER), this.shouldRevertButtonOrder() ? this.addButton(this.createNoButton().onClick(() => this.setValue(!1))).addButton(this.createYesButton().onClick(() => this.setValue(!0))) : this.addButton(this.createYesButton().onClick(() => this.setValue(!0))).addButton(this.createNoButton().onClick(() => this.setValue(!1))) } createYesButton() { return new z } createNoButton() { return new Ft } shouldRevertButtonOrder() { return !1 } }; r(G, "ConfirmationAlert"); var Wt = class extends G { constructor() { super(), this.setText(d.getVariable("notification-allow-online")) } createYesButton() { return new k } }; r(Wt, "NotificationPermissionAlert"); var Ht = class extends x { constructor(t, i = BRAND_NAME, n = NOTIFICATION_ICON) { super(); e(this, "title"); e(this, "text"); e(this, "notification", null); this.text = t, this.title = i, this.icon = n } static isSupported() { if (!window.Notification || !Notification.requestPermission || location.hostname.endsWith(".local")) return !1; if (Notification.permission === "granted") return !0; try { new Notification("") } catch (t) { if (t.name === "TypeError") return !1 } return !0 } static isPermissionGranted() { return Notification.permission === "granted" } static isPermissionDenied() { return Notification.permission === "denied" } static isPermissionUnknown() { return Notification.permission === "default" } static async requestPermission() { if (!this.isSupported()) return !1; try { return await Notification.requestPermission() === "granted" } catch (t) { if (!(t instanceof TypeError)) throw t; return await new Promise(i => { Notification.requestPermission(n => { i(n === "granted") }) }) } } static async promptPermission() { return !this.isSupported() || !this.isPermissionUnknown() || !await new Wt().showAndWait() ? !1 : await this.requestPermission() } show() { return !this.constructor.isSupported() || !this.constructor.isPermissionGranted() ? this : (this.notification && this.notification.close(), this.notification = new Notification(this.title, { body: this.text, icon: this.icon }), this.notification.addEventListener("click", () => { this.dispatchEvent(new Event("click")) }), this) } close() { return this.notification && this.notification.close(), this.notification = null, this } setTitle(t) { return this.title = t, this } setText(t) { return this.text = t, this } setIcon(t) { return this.icon = t, this } onClick(t) { return this.addEventListener("click", t), this } }; r(Ht, "DesktopNotification"); var Bt = class extends G { constructor(s) { super(), this.setDismissable(!1), this.setTitle(d.getVariable("auto-update")), this.appendToBody(...d.getDOMVariable("auto-update-question", { version: new h("strong").text(s) })) } shouldRevertButtonOrder() { return !0 } createYesButton() { return super.createYesButton().icon("circle-up") } createNoButton() { return super.createNoButton().color(c.COLOR_INVISIBLE).icon("clock").label(d.getVariable("maybe-later")) } }; r(Bt, "UpdateAlert"); var Yt = class extends G { constructor() { super(), this.setTitle(d.getVariable("server-eula")).setText(d.getVariable("server-eula-question")).appendToBody(new h("br")).appendToBody(new h("a").href("https://www.minecraft.net/eula").text("https://www.minecraft.net/eula").target("_blank").setAttribute("rel", "noopener nofollow")).setColor(this.constructor.COLOR_SUCCESS) } createYesButton() { return new z().label(d.getVariable("server-accept-eula")) } }; r(Yt, "AcceptEulaAlert"); var Xt = class extends J { constructor() { super(), this.setTitle(d.getVariable("ad")).setText("Please watch this short advertisement while we start your free server for you.").setColor(p.COLOR_SUCCESS).addButton(new y().color(c.COLOR_SUCCESS).label(d.getVariable("server-start")).icon("power-off").onClick(() => this.hide())) } }; r(Xt, "WatchAdAlert"); var P = class extends x { constructor() { super(); e(this, "googletag"); e(this, "isSetup", !1); e(this, "rewardedSlot"); e(this, "adLoadTimeout"); e(this, "initPromise", null); e(this, "initPromiseResolve"); e(this, "initPromiseReject"); e(this, "slotReadyEvent"); e(this, "dismissPromise", null); e(this, "dismissPromiseResolve"); location.search.includes("demo") && (this.constructor.AD_UNIT_PATH = "/22639388115/rewarded_web_example"), window.googletag = this.googletag = window.googletag || { cmd: [] }, this.initNew() } static getInstance() { return this.instance || (this.instance = new this), this.instance } setup() { this.isSetup || (this.isSetup = !0, this.googletag.pubads().addEventListener("rewardedSlotReady", this.handleRewardedSlotReady.bind(this)), this.googletag.pubads().addEventListener("rewardedSlotClosed", this.dismiss.bind(this)), this.googletag.enableServices()) } async initNew() { return this.initPromise !== null ? this.initPromise : (this.initPromise = new Promise((t, i) => { this.initPromiseResolve = t, this.initPromiseReject = i }), this.adLoadTimeout = setTimeout(this.handleNoAdReturned.bind(this), 1e4), this.googletag.cmd.push(this.initializeRewardedAd.bind(this)), this.initPromise) }
                       async show() { return await this.initPromise ? (this.dismissPromise = new Promise(t => { this.dismissPromiseResolve = t }), await new Xt().showAndWait(), this.slotReadyEvent.makeRewardedVisible(), !0) : !1 }
                       async hasAdReady() { return await this.initPromise } async waitForAdToFinish() { return this.dismissPromise }
                       dismiss() { this.googletag.destroySlots([this.rewardedSlot]), this.initPromise = null, this.initPromiseResolve = null, this.initPromiseReject = null, this.slotReadyEvent = null, this.rewardedSlot = null, this.dispatchEvent(new Event(this.constructor.EVENT_AD_RESET)), this.dismissPromiseResolve(), setTimeout(this.initNew.bind(this), this.constructor.REINITIALIZE_TIMEOUT) } 
                      initializeRewardedAd() 
                      { this.setup(), this.rewardedSlot = this.googletag.defineOutOfPageSlot(this.constructor.AD_UNIT_PATH, this.googletag.enums.OutOfPageFormat.REWARDED), this.rewardedSlot && (this.rewardedSlot.addService(this.googletag.pubads()), this.googletag.display(this.rewardedSlot)) }
                       handleNoAdReturned() { this.initPromiseResolve(!1) } handleRewardedSlotReady(t) { this.dispatchEvent(new Event(this.constructor.EVENT_AD_READY)), clearTimeout(this.adLoadTimeout), this.initPromiseResolve(!0), this.slotReadyEvent = t }
                     };
                       r(P, "RewardedAd"), e(P, "AD_UNIT_PATH", "/21726375739,21668746256/ca-video-pub-5781531207509232-tag/Aternos_Rewarded_Video"), e(P, "REINITIALIZE_TIMEOUT", 1e4), e(P, "EVENT_AD_READY", "ad-ready"), e(P, "EVENT_AD_RESET", "ad-reset"), e(P, "instance");
                       var Qt = class extends c { constructor(t = "button", i = null) { super(t, i);
                       e(this, "serverPage");
                       e(this, "additionalStartFields", {});
                       e(this, "rewardedAd");
                       this.onClick(async () => await this.start()), REWARDED && (this.rewardedAd = P.getInstance()) }
                       
                       
                       setServerPage(t) { return this.serverPage = t, this } async start(t = !1) { var o, S, I; if (!ee.isActive()) return this; if (this.serverPage.areAnyActionsWorking()) return this; this.working(); let i = !1; this.rewardedAd && !t && (i = (o = await this.rewardedAd.hasAdReady()) != null ? o : !1); let n = await new b("server/start", { "access-credits": (I = (S = this.serverPage.getAccessCreditsToggle()) == null ? void 0 : S.getValue()) != null ? I : !1, prepare: i, ...this.additionalStartFields }).setResponseClass(Mt).send(); return this.rewardedAd && await this.rewardedAd.waitForAdToFinish(), this.additionalStartFields = {}, n ? !n.wasSuccessful() && A.isError(n.getStatus()) ? (this.reset(), await A.createErrorAlert(n).show(), this) : n.getStatus() === A.EULA ? (this.reset(), await this.acceptEula(), this) : n.getStatus() === A.UPDATE ? (this.reset(), await this.askForUpdate(n.getSoftware(), n.getVersion()), this) : n.getStatus() === A.PREPARED ? (this.reset(), this.rewardedAd && await this.rewardedAd.show(), await this.start(!0), this) : (await Ht.promptPermission(), this.reset(), this) : (this.reset(), this) } async askForUpdate(t, i) { return await new Bt(i).showAndWait() ? this.additionalStartFields.update = t : this.additionalStartFields.dismissUpdate = !0, this.start() } async acceptEula() { return await new Yt().showAndWait() ? (this.additionalStartFields.acceptEula = !0, await this.start(), this) : this } }; r(Qt, "StartButton"); var jt = class extends h { constructor(t = "div", i = null) { var n; super(t, i); e(this, "startButton"); e(this, "accessCreditsToggle"); e(this, "autoUpdateSettings"); e(this, "versionElement"); this.startButton = (n = Qt.select("#start")) == null ? void 0 : n.setServerPage(this), this.accessCreditsToggle = tt.select("#toggle-access-credits"), this.autoUpdateSettings = _t.select(".auto-update-setting"), this.versionElement = h.select("#version"), v.getInstance().onStatus(this.handleStatus.bind(this)) } handleStatus(t) { this.versionElement.text(t.getStatus().getDisplayVersion()) } getAccessCreditsToggle() { return this.accessCreditsToggle } getStartButton() { return this.startButton } areAnyActionsWorking() { var t; return (t = this.startButton) == null ? void 0 : t.isWorking() } }; r(jt, "ServerPage"); jt.select(".main"); })();